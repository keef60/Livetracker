<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ArUco Tracker with Spaghetti Chart, Zones & Playback</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #222;
            color: #eee;
        }

        canvas {
            display: block;
            background: #111;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            user-select: none;
            max-width: 280px;
        }

        #controls button,
        #controls input {
            margin: 4px 0;
            width: 100%;
            padding: 6px;
            font-size: 14px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
        }

        #controls button:hover {
            background-color: #444;
        }

        #speedRange {
            width: 100%;
        }

        #status {
            margin-top: 8px;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
            color: #aaa;
        }

        .zone-label {
            position: absolute;
            font-family: sans-serif;
            font-size: 12px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 5px;
            border-radius: 3px;
            pointer-events: none;
            z-index: 100;
        }
    </style>
    <script type="importmap">
  {
    "imports": {
      "three": "./three.js-dev/build/three.module.js",
      "three/addons/": "./three.js-dev/examples/jsm/"
    }
  }
  </script>
</head>

<body>
    <div id="controls">
        <button id="captureButton">Capture Item Location</button>
        <button id="exportPathButton">Export Movement Path</button>
        <button id="startPlaybackBtn">Start Playback</button>
        <button id="stopPlaybackBtn" disabled>Stop Playback</button>
        <button id="saveDataBtn">Save Path to LocalStorage</button>
        <button id="loadDataBtn">Load Path from LocalStorage</button>
        <label for="speedRange">Playback Speed: <span id="speedDisplay">1x</span></label>
        <input type="range" id="speedRange" min="0.1" max="5" step="0.1" value="1" />
        <div id="status">Status: Waiting for video...</div>
    </div>

    <video id="video" autoplay playsinline></video>
    <canvas id="canvas" width="640" height="480" style="display:none;"></canvas>
    <canvas id="spaghettiChartCanvas"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import AR from './js-aruco2-master/src/aruco.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import POS from './js-aruco2-master/src/posit1.js';

        // ==== Constants & Config ====
        const MARKER_SIZE = 0.16;           // Marker size in meters
        const SMOOTHING_ALPHA = 0.2;        // EMA smoothing factor
        const MAX_DISTANCE_JUMP = 1.5;      // Max allowed jump to filter outliers
        const MAX_PATH_POINTS = 500;        // Max points in the path line

        // ==== Elements & Contexts ====
        const video = document.getElementById('video');
        const hiddenCanvas = document.getElementById('canvas');
        const hiddenCtx = hiddenCanvas.getContext('2d');
        const spaghettiCanvas = document.getElementById('spaghettiChartCanvas');

        // UI elements
        const captureButton = document.getElementById('captureButton');
        const exportButton = document.getElementById('exportPathButton');
        const startPlaybackBtn = document.getElementById('startPlaybackBtn');
        const stopPlaybackBtn = document.getElementById('stopPlaybackBtn');
        const saveDataBtn = document.getElementById('saveDataBtn');
        const loadDataBtn = document.getElementById('loadDataBtn');
        const speedRange = document.getElementById('speedRange');
        const speedDisplay = document.getElementById('speedDisplay');
        const statusDisplay = document.getElementById('status');

        // === Zone Class ===
class Zone {
    constructor({ id, name, bounds, points2D = [], color = 0x00ff00 }) {
        this.id = id;
        this.name = name;
        this.bounds = {
            min: new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.min.z),
            max: new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.max.z),
        };
        this.points2D = points2D; // Optional polygon shape in xz-plane
        this.color = color;

        this.mesh = null;
        this.labelElement = null;
        this.spriteLabel = null;
    }

    // Compute center of zone (average of points2D or bounds)
    getCenter() {
        if (this.points2D.length > 0) {
            let sumX = 0, sumZ = 0;
            this.points2D.forEach(p => {
                sumX += p.x;
                sumZ += p.z;
            });
            return new THREE.Vector3(sumX / this.points2D.length, this.bounds.max.y, sumZ / this.points2D.length);
        } else {
            return new THREE.Vector3().addVectors(this.bounds.min, this.bounds.max).multiplyScalar(0.5);
        }
    }

    // Create 2D label using CSS2D
    createSpriteLabel() {
        const div = document.createElement('div');
        div.className = 'zone-label';
        div.textContent = this.name;

        div.style.padding = '4px 10px';
        div.style.background = 'rgba(0, 128, 0, 0.6)';
        div.style.color = 'white';
        div.style.borderRadius = '5px';
        div.style.fontSize = '14px';
        div.style.fontWeight = 'bold';

        const label = new CSS2DObject(div);
        const center = this.getCenter();
        label.position.set(center.x, center.y + 0.5, center.z);

        this.spriteLabel = label;
        this.labelElement = div;

        return label;
    }

    // Create visual 3D mesh (box if no polygon, shape if polygon)
    createMesh() {
        let mesh;
        if (this.points2D.length >= 3) {
            // Create polygonal shape
            const shape = new THREE.Shape();
            this.points2D.forEach((p, i) => {
                if (i === 0) {
                    shape.moveTo(p.x, p.z);
                } else {
                    shape.lineTo(p.x, p.z);
                }
            });

            const geometry = new THREE.ShapeGeometry(shape);
            geometry.rotateX(-Math.PI / 2); // Lay flat on XZ
            const material = new THREE.MeshBasicMaterial({
                color: this.color,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });

            mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = this.bounds.min.y; // ground level
        } else {
            // Fallback to box
            const size = new THREE.Vector3().subVectors(this.bounds.max, this.bounds.min);
            const center = this.getCenter();
            const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
            const material = new THREE.MeshBasicMaterial({
                color: this.color,
                transparent: true,
                opacity: 0.2
            });
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(center);
        }

        mesh.name = `Zone-${this.id}`;
        this.mesh = mesh;
        return mesh;
    }

    addToScene(scene) {
        if (!this.mesh) this.createMesh();
        scene.add(this.mesh);

        if (!this.spriteLabel) {
            this.createSpriteLabel();
        }
        scene.add(this.spriteLabel);
    }

    setHighlighted(isHighlighted) {
        if (this.mesh) {
            this.mesh.material.opacity = isHighlighted ? 0.8 : 0.4;
            this.mesh.material.color.setHex(isHighlighted ? 0xffff00 : this.color);
        }
    }

    setVisible(visible) {
        if (this.mesh) this.mesh.visible = visible;
        if (this.labelElement) this.labelElement.style.display = visible ? 'block' : 'none';
    }

    contains(position) {
        return (
            position.x >= this.bounds.min.x && position.x <= this.bounds.max.x &&
            position.y >= this.bounds.min.y && position.y <= this.bounds.max.y &&
            position.z >= this.bounds.min.z && position.z <= this.bounds.max.z
        );
    }

    toString() {
        return `Zone ${this.id} [${this.name}] from ${this.bounds.min.toArray()} to ${this.bounds.max.toArray()}`;
    }
}

        // ==== Tracker Class ====
        class WarehouseTracker {
            constructor() {
                // POSIT setup for pose estimation
                this.posit = new POS.Posit(MARKER_SIZE, hiddenCanvas.width);

                // ArUco marker detector
                this.detector = new AR.Detector({ dictionaryName: 'ARUCO' });

                // Three.js scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas: spaghettiCanvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x111111);


                this.labelRenderer = new CSS2DRenderer();
                this.labelRenderer.setSize(window.innerWidth, window.innerHeight);
                this.labelRenderer.domElement.style.position = 'absolute';
                this.labelRenderer.domElement.style.top = '0';
                this.labelRenderer.domElement.style.pointerEvents = 'none';
                document.body.appendChild(this.labelRenderer.domElement);


                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableZoom = true;
                this.controls.minDistance = 2;
                this.controls.maxDistance = 50;

                this.camera.position.set(0, 10, 20);
                this.camera.up.set(0, 0, -1);
                this.camera.lookAt(0, 0, 0);
                this.controls.update();

                this.scene.add(new THREE.GridHelper(10, 10));

                // Forklift path tracking setup
                this.points = new Array(MAX_PATH_POINTS).fill(null);
                this.currentPointIndex = 0;

                // Create a fixed-size BufferGeometry for performance
                const positions = new Float32Array(MAX_PATH_POINTS * 3); // x,y,z for each point
                this.lineGeometry = new THREE.BufferGeometry();
                this.lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
                this.line = new THREE.Line(this.lineGeometry, this.lineMaterial);
                this.scene.add(this.line);

                // Playback line
                this.playbackMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                this.playbackLineGeometry = new THREE.BufferGeometry();
                this.playbackLinePositions = new Float32Array(MAX_PATH_POINTS * 3);
                this.playbackLineGeometry.setAttribute('position', new THREE.BufferAttribute(this.playbackLinePositions, 3));
                this.playbackLine = new THREE.Line(this.playbackLineGeometry, this.playbackMaterial);
                this.scene.add(this.playbackLine);
                this.playbackLine.visible = false;

                this.smoothedPos = null;
                this.forkliftPos = new THREE.Vector3();
                this.currentZoneId = null;
                this.storedItems = [];

                // Store path points with timestamps
                this.trackedPathPoints = [];

                // Playback controls
                this.isPlayingBack = false;
                this.playbackIndex = 0;
                this.playbackSpeed = 1; // multiplier
                this.playbackLastUpdateTime = 0;

                this.animate = this.animate.bind(this);

                //Zone creation
                this.zones = this.createZones();
                this.currentZone = null;

                //Transporter visit log data
                this.zoneVisitLog = []; // Records each entry/exit with timestamps
                this.zoneEntryTime = null; // Timestamp when forklift entered current zone


            }

            createZones() {
                const zoneData = [
                    {
                        "id": 1,
                        "name": "Zone 1",
                        "bounds": {
                            "min": {
                                "x": 5.3333330154419,
                                "y": 0,
                                "z": 2.16666412353516
                            },
                            "max": {
                                "x": 8.3333330154419,
                                "y": 3,
                                "z": 4.1666717529297
                            }
                        },
                        "points2D": [
                            
                        ],
                        "color": 15523448
                    },
                ];
                const zones = zoneData.map(zone => {return new Zone(zone) });
                zones.forEach(zone => zone.addToScene(this.scene));

                return zones;
            }

            estimatePose(marker) {
                const corners = marker.corners.map(c => ({ x: c.x, y: c.y }));
                const pose = this.posit.pose(corners);
                if (!pose || !pose.bestRotation || !pose.bestTranslation) return null;
                return {
                    translation: pose.bestTranslation,
                    rotation: pose.bestRotation
                };
            }

            updatePathLine(newPos) {
                // Add new point to the circular buffer for rendering
                this.points[this.currentPointIndex] = newPos.clone();
                this.currentPointIndex = (this.currentPointIndex + 1) % MAX_PATH_POINTS;

                // Add timestamped position for evaluation
                this.trackedPathPoints.push({
                    position: newPos.clone(),
                    timestamp: new Date()
                });

                // Limit stored points to MAX_PATH_POINTS * 10 to keep memory manageable
                if (this.trackedPathPoints.length > MAX_PATH_POINTS * 10) {
                    this.trackedPathPoints.shift();
                }

                // Update BufferGeometry positions attribute (rendered path)
                const positions = this.lineGeometry.attributes.position.array;
                let idx = 0;

                for (let i = 0; i < MAX_PATH_POINTS; i++) {
                    const point = this.points[(this.currentPointIndex + i) % MAX_PATH_POINTS];
                    if (point) {
                        positions[idx++] = point.x;
                        positions[idx++] = point.y;
                        positions[idx++] = point.z;
                    } else {
                        positions[idx++] = 0;
                        positions[idx++] = 0;
                        positions[idx++] = 0;
                    }
                }
                this.lineGeometry.attributes.position.needsUpdate = true;
            }

            processFrame() {
                if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

                // Draw video frame to hidden canvas for processing
                hiddenCtx.drawImage(video, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
                const imageData = hiddenCtx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);

                const markers = this.detector.detect(imageData);

                let sumPos = new THREE.Vector3(0, 0, 0);
                let totalWeight = 0;
                let closestMarker = null;
                let closestZ = Infinity;

                markers.forEach(marker => {
                    const pose = this.estimatePose(marker);
                    if (!pose) return;

                    const t = pose.translation;
                    if (
                        isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ||
                        !isFinite(t[0]) || !isFinite(t[1]) || !isFinite(t[2])
                    ) return;

                    const pos = new THREE.Vector3(t[0], t[1], t[2]);
                    if (isNaN(pos.z) || !isFinite(pos.z)) return;

                    // Accumulate for average pose
                    sumPos.add(pos);
                    totalWeight++;

                    if (pos.z < closestZ) {
                        closestZ = pos.z;
                        closestMarker = marker;
                    }
                });

                // Optional: Still record marker ID
                if (closestMarker) {
                    this.closestMarkerId = closestMarker.id;
                } else {
                    this.closestMarkerId = null;
                }

                if (totalWeight > 0) {
                    const avgPos = sumPos.divideScalar(totalWeight);

                    if (!this.smoothedPos) {
                        this.smoothedPos = avgPos.clone();
                    } else {
                        if (this.smoothedPos.distanceTo(avgPos) > MAX_DISTANCE_JUMP) {
                            console.warn('Outlier detected, skipping frame');
                            return; // Skip frame
                        } else {
                            this.smoothedPos.lerp(avgPos, SMOOTHING_ALPHA);
                        }
                    }

                    this.forkliftPos.copy(this.smoothedPos);
                    this.updatePathLine(this.forkliftPos);


                    // === âœ… Zone Detection ===
                    const newZone = this.zones?.find(zone => zone.id === this.closestMarkerId);
                    if (newZone?.id !== this.currentZone?.id) {
                        const now = new Date();

                        // Exiting old zone
                        if (this.currentZone && this.zoneEntryTime) {
                            const duration = (now - this.zoneEntryTime) / 1000; // in seconds
                            this.zoneVisitLog.push({
                                zoneId: this.currentZone.id,
                                zoneName: this.currentZone.name,
                                enteredAt: this.zoneEntryTime.toISOString(),
                                exitedAt: now.toISOString(),
                                duration: duration.toFixed(2) + 's'
                            });
                            console.log(`ðŸ Exited ${this.currentZone.name} after ${duration.toFixed(2)}s`);
                        }

                        // Entering new zone
                        if (newZone) {
                            console.log(`ðŸš§ Entered ${newZone.name}`);
                            this.zoneEntryTime = now;
                        } else {
                            this.zoneEntryTime = null;
                        }

                        if (this.currentZone) this.currentZone.setHighlighted(false);
                        if (newZone) newZone.setHighlighted(true);

                        this.currentZone = newZone;
                    }

                }
            }

            exportZoneVisitLog() {
                if (this.zoneVisitLog.length === 0) {
                    alert('No zone visit data to export.');
                    return;
                }

                const blob = new Blob([JSON.stringify(this.zoneVisitLog, null, 2)], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `zone_visits_${new Date().toISOString()}.json`;
                a.click();

                URL.revokeObjectURL(url);
            }

            animate(time = 0) {
                requestAnimationFrame(this.animate);

                if (!this.isPlayingBack) {
                    this.processFrame();
                    statusDisplay.textContent = `Status: Tracking - Zone: ${this.currentZone ? this.currentZone.name : 'Unknown'}`;
                } else {
                    this.playback(time);
                }

                this.zones.forEach(zone => {
                    if (zone.spriteLabel) {
                        zone.spriteLabel.quaternion.copy(this.camera.quaternion);
                    }
                });
                this.labelRenderer.render(this.scene, this.camera);

                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            updateZoneLabels() {
                this.zones.forEach(zone => {
                    if (!zone.labelElement) return;

                    const center = zone.getCenter();
                    const pos = center.clone().project(this.camera);

                    const x = (pos.x * 0.5 + 0.5) * this.renderer.domElement.clientWidth;
                    const y = (-pos.y * 0.5 + 0.5) * this.renderer.domElement.clientHeight;

                    zone.labelElement.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                    zone.labelElement.style.display = (pos.z < 1 && pos.z > -1) ? 'block' : 'none';
                });
            }

            captureItem() {

                const itemID = prompt('Enter Item ID:');
                if (!itemID) return alert('Item ID is required');

                this.storedItems.push({
                    id: itemID,
                    position: this.forkliftPos.clone(),
                    zone: this.currentZone?.name || 'Unknown',
                    timestamp: new Date()
                });

                const labelDiv = document.createElement('div');
                labelDiv.className = 'label';
                labelDiv.textContent = itemID;
                labelDiv.style.marginTop = '-1em';
                labelDiv.style.padding = '4px 8px';
                labelDiv.style.background = 'rgba(0, 0, 0, 0.7)';
                labelDiv.style.color = 'white';
                labelDiv.style.borderRadius = '4px';
                labelDiv.style.fontSize = '12px';

                const label = new CSS2DObject(labelDiv);
                label.position.set(0, 0.4, 0); // above the item box

                // Create visual marker in 3D
                const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
                const box = new THREE.Mesh(geometry, material);
                box.position.copy(this.forkliftPos);
                box.name = `Item-${itemID}`;
                this.scene.add(box);
                box.add(label); // attach label to mesh


                alert(`Captured item '${itemID}' at ${box.position.toArray().map(n => n.toFixed(2)).join(', ')}`);

            }

            exportTrackedPath() {
                if (this.trackedPathPoints.length === 0) {
                    alert('No path data to export.');
                    return;
                }

                const exportData = this.trackedPathPoints.map(entry => ({
                    x: entry.position.x,
                    y: entry.position.y,
                    z: entry.position.z,
                    timestamp: entry.timestamp.toISOString()
                }));

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `forklift_path_${new Date().toISOString()}.json`;
                a.click();

                URL.revokeObjectURL(url);
            }

            saveToLocalStorage() {
                if (this.trackedPathPoints.length === 0) {
                    alert('No path data to save.');
                    return;
                }
                try {
                    const dataToSave = this.trackedPathPoints.map(entry => ({
                        x: entry.position.x,
                        y: entry.position.y,
                        z: entry.position.z,
                        timestamp: entry.timestamp.toISOString()
                    }));
                    localStorage.setItem('trackedPathData', JSON.stringify(dataToSave));
                    alert('Path data saved to LocalStorage.');
                } catch (e) {
                    alert('Error saving data: ' + e.message);
                }
            }

            loadFromLocalStorage() {
                try {
                    const dataString = localStorage.getItem('trackedPathData');
                    if (!dataString) {
                        alert('No saved path data found in LocalStorage.');
                        return;
                    }
                    const loadedData = JSON.parse(dataString);
                    if (!Array.isArray(loadedData)) throw new Error('Invalid data format.');

                    // Clear current path and load
                    this.trackedPathPoints = loadedData.map(entry => ({
                        position: new THREE.Vector3(entry.x, entry.y, entry.z),
                        timestamp: new Date(entry.timestamp)
                    }));

                    // Also load the last MAX_PATH_POINTS positions into the path line for rendering
                    this.points = new Array(MAX_PATH_POINTS).fill(null);
                    this.currentPointIndex = 0;
                    for (const entry of this.trackedPathPoints.slice(-MAX_PATH_POINTS)) {
                        this.updatePathLine(entry.position);
                    }
                    alert('Loaded path data from LocalStorage.');
                } catch (e) {
                    alert('Error loading data: ' + e.message);
                }
            }

            // Playback methods
            startPlayback() {
                if (this.trackedPathPoints.length === 0) {
                    alert('No path data to play back.');
                    return;
                }
                this.isPlayingBack = true;
                this.playbackIndex = 0;
                this.playbackLine.visible = true;
                this.playbackLastUpdateTime = 0;
                statusDisplay.textContent = 'Status: Playback started.';
            }

            stopPlayback() {
                this.isPlayingBack = false;
                this.playbackLine.visible = false;
                statusDisplay.textContent = 'Status: Playback stopped.';
            }

            playback(time) {
                if (!this.isPlayingBack) return;

                if (!this.playbackLastUpdateTime) {
                    this.playbackLastUpdateTime = time;
                    return;
                }

                // Advance playback index based on speed and elapsed time
                const elapsed = (time - this.playbackLastUpdateTime) * this.playbackSpeed;
                // Advance the index proportionally -  assume ~30 FPS so approx 33 ms per frame, we adapt:
                const pointsToAdvance = Math.floor(elapsed / 30);
                if (pointsToAdvance > 0) {
                    this.playbackIndex += pointsToAdvance;
                    this.playbackLastUpdateTime = time;
                }

                if (this.playbackIndex >= this.trackedPathPoints.length) {
                    this.stopPlayback();
                    return;
                }

                // Prepare playback path line geometry up to current playback index
                const len = Math.min(this.playbackIndex, MAX_PATH_POINTS);
                for (let i = 0; i < MAX_PATH_POINTS; i++) {
                    let pos;
                    if (i < len) {
                        const p = this.trackedPathPoints[this.playbackIndex - len + i];
                        pos = p ? p.position : new THREE.Vector3(0, 0, 0);
                    } else {
                        pos = new THREE.Vector3(0, 0, 0);
                    }
                    this.playbackLinePositions[i * 3] = pos.x;
                    this.playbackLinePositions[i * 3 + 1] = pos.y;
                    this.playbackLinePositions[i * 3 + 2] = pos.z;
                }
                this.playbackLineGeometry.attributes.position.needsUpdate = true;

                // Move the camera to follow playback point (optional)
                const currentPoint = this.trackedPathPoints[this.playbackIndex].position;
                this.camera.position.lerp(new THREE.Vector3(currentPoint.x, currentPoint.y + 5, currentPoint.z + 10), 0.1);
                this.camera.lookAt(currentPoint);
            }

            setPlaybackSpeed(speed) {
                this.playbackSpeed = speed;
            }
        }

        // ==== Setup & Initialization ====
        const tracker = new WarehouseTracker();

        // Webcam setup & start animation after video metadata ready
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    hiddenCanvas.width = video.videoWidth;
                    hiddenCanvas.height = video.videoHeight;
                    tracker.posit._width = hiddenCanvas.width; // update POSIT width
                    tracker.animate();
                    statusDisplay.textContent = 'Status: Video started, tracking...';
                };
            })
            .catch(err => {
                alert('Error accessing webcam: ' + err);
                statusDisplay.textContent = 'Status: Webcam access denied or error.';
            });

        // ==== UI Event Listeners ====
        captureButton.addEventListener('click', () => {
            tracker.captureItem();
        });

        exportButton.addEventListener('click', () => {
            tracker.exportTrackedPath();
        });

        startPlaybackBtn.addEventListener('click', () => {
            tracker.startPlayback();
            startPlaybackBtn.disabled = true;
            stopPlaybackBtn.disabled = false;
        });

        stopPlaybackBtn.addEventListener('click', () => {
            tracker.stopPlayback();
            startPlaybackBtn.disabled = false;
            stopPlaybackBtn.disabled = true;
        });

        saveDataBtn.addEventListener('click', () => {
            tracker.saveToLocalStorage();
        });

        loadDataBtn.addEventListener('click', () => {
            tracker.loadFromLocalStorage();
        });

        speedRange.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            tracker.setPlaybackSpeed(speed);
            speedDisplay.textContent = speed.toFixed(1) + 'x';
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            tracker.camera.aspect = window.innerWidth / window.innerHeight;
            tracker.camera.updateProjectionMatrix();
            tracker.renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>
