<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ArUco Tracker with Spaghetti Chart, Zones & Playback</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #222;
            color: #eee;
        }

        canvas {
            display: block;
            background: #111;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 6px;
            user-select: none;
            max-width: 240px;
            font-size: 13px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        #controls button,
        #controls input,
        #controls select {
            margin: 0;
            padding: 4px 6px;
            font-size: 13px;
            border-radius: 3px;
            border: none;
            width: 100%;
            box-sizing: border-box;
        }

        #controls button:hover {
            background-color: #444;
        }

        #speedRange {
            width: 100%;
        }

        #status {
            margin-top: 4px;
            font-size: 12px;
            text-align: center;
            color: #aaa;
        }

        #controls hr {
            margin: 8px 0;
            border: 0;
            border-top: 1px solid #555;
        }


        #speedRange {
            width: 100%;
        }

        #status {
            margin-top: 8px;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
            color: #aaa;
        }

        .zone-label {
            position: absolute;
            font-family: sans-serif;
            font-size: 12px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 5px;
            border-radius: 3px;
            pointer-events: none;
            z-index: 100;
        }
    </style>
    <script type="importmap">
  {
    "imports": {
      "three": "./three.js-dev/build/three.module.js",
      "three/addons/": "./three.js-dev/examples/jsm/"
    }
  }
  </script>
</head>

<body>
    <div id="controls">
        <button id="captureButton">Capture Item Location</button>
        <button id="exportPathButton">Export Movement Path</button>
        <button id="startPlaybackBtn">Start Playback</button>
        <button id="stopPlaybackBtn" disabled>Stop Playback</button>
        <button id="saveDataBtn">Save Path to LocalStorage</button>
        <button id="loadDataBtn">Load Path from LocalStorage</button>

        <!-- New default view buttons -->
        <button id="btnTopView">Top View</button>
        <button id="btnFrontView">Front View</button>
        <button id="btnSideView">Side View</button>
        <button id="btnIsoView">Isometric View</button>

        <label for="speedRange">Playback Speed: <span id="speedDisplay">1x</span></label>
        <input type="range" id="speedRange" min="0.1" max="5" step="0.1" value="1" />
        <div id="status">Status: Waiting for video...</div>

        <hr>
        <label for="zoneFilter">Filter by Zone:</label>
        <select id="zoneFilter">
            <option value="">All Zones</option>
            <option value="2">Packing</option>
            <!-- Add other zone options here -->
        </select>

        <label for="levelFilter">Filter by Level:</label>
        <select id="levelFilter">
            <option value="">All Levels</option>
            <option value="floor">Floor</option>
            <option value="mid">Mid</option>
            <option value="top">Top</option>
        </select>

        <button id="filterItemsBtn">Filter Items</button>

        <input type="text" id="searchItemInput" placeholder="Enter Item ID" />
        <button id="searchItemBtn">Search Item</button>
    </div>


    <video id="video" autoplay playsinline></video>
    <canvas id="canvas" width="640" height="480" style="display:none;"></canvas>
    <canvas id="spaghettiChartCanvas"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import AR from './js-aruco2-master/src/aruco.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import POS from './js-aruco2-master/src/posit1.js';

        // ==== Constants & Config ====
        const MARKER_SIZE = 0.16;           // Marker size in meters
        const SMOOTHING_ALPHA = 0.2;        // EMA smoothing factor
        const MAX_DISTANCE_JUMP = 1.5;      // Max allowed jump to filter outliers
        const MAX_PATH_POINTS = 500;        // Max points in the path line

        // ==== Elements & Contexts ====
        const video = document.getElementById('video');
        const hiddenCanvas = document.getElementById('canvas');
        const hiddenCtx = hiddenCanvas.getContext('2d');
        const spaghettiCanvas = document.getElementById('spaghettiChartCanvas');

        // UI elements
        const captureButton = document.getElementById('captureButton');
        const exportButton = document.getElementById('exportPathButton');
        const startPlaybackBtn = document.getElementById('startPlaybackBtn');
        const stopPlaybackBtn = document.getElementById('stopPlaybackBtn');
        const saveDataBtn = document.getElementById('saveDataBtn');
        const loadDataBtn = document.getElementById('loadDataBtn');
        const speedRange = document.getElementById('speedRange');
        const speedDisplay = document.getElementById('speedDisplay');
        const statusDisplay = document.getElementById('status');
        // === Forklift Class ===
        class ForkliftController {
            constructor(forkliftModel, camera, options = {}) {
                this.forkliftModel = forkliftModel;
                this.camera = camera;

                this.velocity = 0;
                this.acceleration = options.acceleration ?? 0.02;
                this.deceleration = options.deceleration ?? 0.01;
                this.maxSpeed = options.maxSpeed ?? 0.1;
                this.rotationSpeed = options.rotationSpeed ?? 0.05;
                this.direction = new THREE.Vector3(0, 0, 1);

                this.lastTarget = null;
                this.tolerance = options.tolerance ?? 0.5;

                this.trailPoints = [];
                this.trailGeometry = new THREE.BufferGeometry();
                this.trailMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
                this.trailLine = new THREE.Line(this.trailGeometry, this.trailMaterial);

                if (this.forkliftModel.parent) {
                    this.forkliftModel.parent.add(this.trailLine);
                }

                this.followMode = true;
            }

            getAverageMarkerPosition(markers, canvas) {
                // Compute average marker center positions in world coords
                const avgPosition = new THREE.Vector3(0, 0, 0);
                if (markers.length === 0) return null;

                markers.forEach(marker => {
                    const center = marker.corners.reduce((sum, c) => sum.add(new THREE.Vector2(c.x, c.y)), new THREE.Vector2()).divideScalar(marker.corners.length);
                    avgPosition.x += (center.x / canvas.width - 0.5) * 10;
                    avgPosition.z += (0.5 - center.y / canvas.height) * 10;
                });
                avgPosition.divideScalar(markers.length);
                avgPosition.y = 0;
                return avgPosition;
            }

            update(markers, canvas) {
                if (!this.forkliftModel) return;

                const target = this.getAverageMarkerPosition(markers, canvas);
                if (!target) {
                    this.velocity = Math.max(0, this.velocity - this.deceleration);
                    return;
                }

                const forkliftPos = this.forkliftModel.position;

                if (!this.lastTarget || this.lastTarget.distanceTo(target) > this.tolerance) {
                    this.lastTarget = target.clone();
                }

                if (this.lastTarget) {
                    const desiredDir = new THREE.Vector3().subVectors(this.lastTarget, forkliftPos);
                    desiredDir.y = 0;
                    const distance = desiredDir.length();

                    if (distance > 0.05) {
                        desiredDir.normalize();
                        const angleBetween = this.direction.angleTo(desiredDir);
                        const goingBackward = angleBetween > Math.PI / 2;

                        if (goingBackward) {
                            this.velocity = Math.max(this.velocity - this.deceleration, -this.maxSpeed);
                        } else {
                            this.velocity = Math.min(this.velocity + this.acceleration, this.maxSpeed);
                        }

                        const cross = new THREE.Vector3().crossVectors(this.direction, desiredDir);
                        if (cross.y !== 0) {
                            this.direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotationSpeed * Math.sign(cross.y));
                        }

                        const movement = this.direction.clone().multiplyScalar(this.velocity);
                        this.forkliftModel.position.add(movement);
                        this.forkliftModel.lookAt(this.forkliftModel.position.clone().add(this.direction));
                    } else {
                        this.velocity = Math.max(0, this.velocity - this.deceleration);
                    }
                }

                // Update trail
                const lastPoint = this.trailPoints[this.trailPoints.length - 1];
                const currentPos = this.forkliftModel.position.clone();
                if (!lastPoint || lastPoint.distanceTo(currentPos) > 0.02) {
                    this.trailPoints.push(currentPos.clone());
                    if (this.trailPoints.length > 1000) this.trailPoints.shift();

                    this.trailGeometry.setFromPoints(this.trailPoints);
                    this.trailLine.geometry = this.trailGeometry;
                }

                // Camera follow
                if (this.followMode) {
                    const offset = new THREE.Vector3(
                        -Math.sin(this.forkliftModel.rotation.y) * 5,
                        3,
                        -Math.cos(this.forkliftModel.rotation.y) * 5
                    );

                    const targetCamPos = this.forkliftModel.position.clone().add(offset);
                    this.camera.position.lerp(targetCamPos, 0.1);
                    this.camera.lookAt(this.forkliftModel.position);
                    this.camera.up.set(0, 1, 0);
                }
            }
        }

        // === Zone Class ===
        class Zone {
            constructor({ id, name, bounds, points2D = [], color = 0x00ff00 }) {
                this.id = id;
                this.name = name;
                this.bounds = {
                    min: new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.min.z),
                    max: new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.max.z),
                };
                this.points2D = points2D; // Optional polygon shape in xz-plane
                this.color = color;

                this.mesh = null;
                this.labelElement = null;
                this.spriteLabel = null;
            }

            // Compute center of zone (average of points2D or bounds)
            getCenter() {
                if (this.points2D.length > 0) {
                    let sumX = 0, sumZ = 0;
                    this.points2D.forEach(p => {
                        sumX += p.x;
                        sumZ += p.z;
                    });
                    return new THREE.Vector3(sumX / this.points2D.length, this.bounds.max.y, sumZ / this.points2D.length);
                } else {
                    return new THREE.Vector3().addVectors(this.bounds.min, this.bounds.max).multiplyScalar(0.5);
                }
            }

            // Create 2D label using CSS2D
            createSpriteLabel() {
                const div = document.createElement('div');
                div.className = 'zone-label';
                div.textContent = this.name;

                div.style.padding = '4px 10px';
                div.style.background = 'rgba(0, 128, 0, 0.6)';
                div.style.color = 'white';
                div.style.borderRadius = '5px';
                div.style.fontSize = '14px';
                div.style.fontWeight = 'bold';

                const label = new CSS2DObject(div);
                const center = this.getCenter();
                label.position.set(center.x, center.y + 0.5, center.z);

                this.spriteLabel = label;
                this.labelElement = div;

                return label;
            }

            // Create visual 3D mesh (box if no polygon, shape if polygon)
            createMesh() {
                let mesh;
                if (this.points2D.length >= 3) {
                    // Create polygonal shape
                    const shape = new THREE.Shape();
                    this.points2D.forEach((p, i) => {
                        if (i === 0) {
                            shape.moveTo(p.x, p.z);
                        } else {
                            shape.lineTo(p.x, p.z);
                        }
                    });

                    const geometry = new THREE.ShapeGeometry(shape);
                    geometry.rotateX(-Math.PI / 2); // Lay flat on XZ
                    const material = new THREE.MeshBasicMaterial({
                        color: this.color,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide
                    });

                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.y = this.bounds.min.y; // ground level
                } else {
                    // Fallback to box
                    const size = new THREE.Vector3().subVectors(this.bounds.max, this.bounds.min);
                    const center = this.getCenter();
                    const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
                    const material = new THREE.MeshBasicMaterial({
                        color: this.color,
                        transparent: true,
                        opacity: 0.2
                    });
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(center);
                }

                mesh.name = `Zone-${this.id}`;
                this.mesh = mesh;
                return mesh;
            }

            addToScene(scene) {
                if (!this.mesh) this.createMesh();
                scene.add(this.mesh);

                if (!this.spriteLabel) {
                    this.createSpriteLabel();
                }
                scene.add(this.spriteLabel);
            }

            setHighlighted(isHighlighted) {
                if (this.mesh) {
                    this.mesh.material.opacity = isHighlighted ? 0.8 : 0.4;
                    this.mesh.material.color.setHex(isHighlighted ? 0xffff00 : this.color);
                }
            }

            setVisible(visible) {
                if (this.mesh) this.mesh.visible = visible;
                if (this.labelElement) this.labelElement.style.display = visible ? 'block' : 'none';
            }

            contains(position) {
                return (
                    position.x >= this.bounds.min.x && position.x <= this.bounds.max.x &&
                    position.y >= this.bounds.min.y && position.y <= this.bounds.max.y &&
                    position.z >= this.bounds.min.z && position.z <= this.bounds.max.z
                );
            }

            toString() {
                return `Zone ${this.id} [${this.name}] from ${this.bounds.min.toArray()} to ${this.bounds.max.toArray()}`;
            }
        }

        // ==== Tracker Class ====
        class WarehouseTracker {
            constructor(config = {}) {

                this.loader = new GLTFLoader();
                this.forkliftModel = null;
                this.loader.load(
                    './forklift.gltf',  // Replace with your model path or URL
                    (gltf) => {
                        this.forkliftModel = gltf.scene;
                        this.forkliftModel.scale.set(1, 1, 1); // Adjust scale if needed
                        this.scene.add(this.forkliftModel);
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading forklift GLTF model:', error);
                    }
                );

                // Pallet and rack parameters
                this.palletLength = config.palletLength ?? 1.2;
                this.palletWidth = config.palletWidth ?? 0.8;
                this.palletHeight = config.palletHeight ?? 0.144;
                this.maxItemsPerRow = config.maxItemsPerRow ?? 5;
                this.levelHeights = config.levelHeights ?? { floor: 0, mid: 1, top: 2 };



                this.palletModel = null;
                this.loader.load(
                    './pallet1.gltf',  // <-- Replace with actual path to your pallet model
                    (gltf) => {
                        this.palletModel = gltf.scene;
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading pallet GLTF model:', error);
                    }
                );

                // Gap between rack levels 
                this.rackLevelGap = config.rackLevelGap ?? 2.5;
                this.rackSlotGap = config.rackSlotGap ?? 0.6;


                // POSIT setup for pose estimation
                this.posit = new POS.Posit(MARKER_SIZE, hiddenCanvas.width);

                // ArUco marker detector
                this.detector = new AR.Detector({ dictionaryName: 'ARUCO' });

                // Three.js scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas: spaghettiCanvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0xffffff);

                // === 💡 Lighting Setup ===
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // soft global light
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10); // position above and angled
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                // Optional: Point light for forklift (if dynamic lighting is needed)
                const forkliftLight = new THREE.PointLight(0xffaa00, 1, 10); // warm glow near forklift
                forkliftLight.position.set(0, 2, 0); // will attach later
                this.forkliftLight = forkliftLight;


                this.itemMeshes = [];

                this.labelRenderer = new CSS2DRenderer();
                this.labelRenderer.setSize(window.innerWidth, window.innerHeight);
                this.labelRenderer.domElement.style.position = 'absolute';
                this.labelRenderer.domElement.style.top = '0';
                this.labelRenderer.domElement.style.pointerEvents = 'none';
                document.body.appendChild(this.labelRenderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableZoom = true;
                this.controls.minDistance = 2;
                this.controls.maxDistance = 50;

                this.camera.position.set(0, 10, 20);
                this.camera.up.set(0, 0, -1);
                this.camera.lookAt(0, 0, 0);
                this.controls.update();

                this.scene.add(new THREE.GridHelper(10, 10));

                // Forklift path tracking setup
                this.points = new Array(MAX_PATH_POINTS).fill(null);
                this.currentPointIndex = 0;

                // Create a fixed-size BufferGeometry for performance
                const positions = new Float32Array(MAX_PATH_POINTS * 3); // x,y,z for each point
                this.lineGeometry = new THREE.BufferGeometry();
                this.lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
                this.line = new THREE.Line(this.lineGeometry, this.lineMaterial);
                this.scene.add(this.line);

                // Playback line
                this.playbackMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                this.playbackLineGeometry = new THREE.BufferGeometry();
                this.playbackLinePositions = new Float32Array(MAX_PATH_POINTS * 3);
                this.playbackLineGeometry.setAttribute('position', new THREE.BufferAttribute(this.playbackLinePositions, 3));
                this.playbackLine = new THREE.Line(this.playbackLineGeometry, this.playbackMaterial);
                this.scene.add(this.playbackLine);
                this.playbackLine.visible = false;

                this.smoothedPos = null;
                this.forkliftPos = new THREE.Vector3();
                this.currentZoneId = null;
                this.storedItems = [];

                // Store path points with timestamps
                this.trackedPathPoints = [];

                // Playback controls
                this.isPlayingBack = false;
                this.playbackIndex = 0;
                this.playbackSpeed = 1; // multiplier
                this.playbackLastUpdateTime = 0;

                this.animate = this.animate.bind(this);

                //Zone creation
                this.zones = this.createZones();
                this.currentZone = null;

                //Transporter visit log data
                this.zoneVisitLog = []; // Records each entry/exit with timestamps
                this.zoneEntryTime = null; // Timestamp when forklift entered current zone


            }

            createZones() {
                const zoneData = [
                    {
                        "id": 2,
                        "name": "Packing",
                        "bounds": {
                            "min": {
                                "x": 5.3333330154419,
                                "y": 0,
                                "z": 2.16666412353516
                            },
                            "max": {
                                "x": 8.3333330154419,
                                "y": 3,
                                "z": 4.1666717529297
                            }
                        },
                        "points2D": [

                        ],
                        "color": 11822397
                    }
                ];
                const zones = zoneData.map(zone => { return new Zone(zone) });
                zones.forEach(zone => zone.addToScene(this.scene));

                return zones;
            }

            estimatePose(marker) {
                const corners = marker.corners.map(c => ({ x: c.x, y: c.y }));
                const pose = this.posit.pose(corners);
                if (!pose || !pose.bestRotation || !pose.bestTranslation) return null;
                return {
                    translation: pose.bestTranslation,
                    rotation: pose.bestRotation
                };
            }

            updatePathLine(newPos) {
                // Add new point to the circular buffer for rendering
                this.points[this.currentPointIndex] = newPos.clone();
                this.currentPointIndex = (this.currentPointIndex + 1) % MAX_PATH_POINTS;

                // Add timestamped position for evaluation
                this.trackedPathPoints.push({
                    position: newPos.clone(),
                    timestamp: new Date()
                });

                // Limit stored points to MAX_PATH_POINTS * 10 to keep memory manageable
                if (this.trackedPathPoints.length > MAX_PATH_POINTS * 10) {
                    this.trackedPathPoints.shift();
                }

                // Update BufferGeometry positions attribute (rendered path)
                const positions = this.lineGeometry.attributes.position.array;
                let idx = 0;

                for (let i = 0; i < MAX_PATH_POINTS; i++) {
                    const point = this.points[(this.currentPointIndex + i) % MAX_PATH_POINTS];
                    if (point) {
                        positions[idx++] = point.x;
                        positions[idx++] = point.y;
                        positions[idx++] = point.z;
                    } else {
                        positions[idx++] = 0;
                        positions[idx++] = 0;
                        positions[idx++] = 0;
                    }
                }
                this.lineGeometry.attributes.position.needsUpdate = true;
            }

            processFrame() {
                if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

                // Draw video frame to hidden canvas for processing
                hiddenCtx.drawImage(video, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
                const imageData = hiddenCtx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);

                const markers = this.detector.detect(imageData);

                let sumPos = new THREE.Vector3(0, 0, 0);
                let totalWeight = 0;
                let closestMarker = null;
                let closestZ = Infinity;

                markers.forEach(marker => {
                    const pose = this.estimatePose(marker);
                    if (!pose) return;

                    const t = pose.translation;
                    if (
                        isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ||
                        !isFinite(t[0]) || !isFinite(t[1]) || !isFinite(t[2])
                    ) return;

                    const pos = new THREE.Vector3(t[0], t[1], t[2]);
                    if (isNaN(pos.z) || !isFinite(pos.z)) return;

                    // Accumulate for average pose
                    sumPos.add(pos);
                    totalWeight++;

                    if (pos.z < closestZ) {
                        closestZ = pos.z;
                        closestMarker = marker;
                    }
                });

                // Optional: Still record marker ID
                if (closestMarker) {
                    this.closestMarkerId = closestMarker.id;
                } else {
                    this.closestMarkerId = null;
                }

                if (totalWeight > 0) {
                    const avgPos = sumPos.divideScalar(totalWeight);

                    if (!this.smoothedPos) {
                        this.smoothedPos = avgPos.clone();
                    } else {
                        if (this.smoothedPos.distanceTo(avgPos) > MAX_DISTANCE_JUMP) {
                            console.warn('Outlier detected, skipping frame');
                            return; // Skip frame
                        } else {
                            this.smoothedPos.lerp(avgPos, SMOOTHING_ALPHA);
                        }
                    }

                    this.forkliftPos.copy(this.smoothedPos);
                    this.updatePathLine(this.forkliftPos);


                    // === ✅ Zone Detection ===
                    const newZone = this.zones?.find(zone => zone.id === this.closestMarkerId);
                    if (newZone?.id !== this.currentZone?.id) {
                        const now = new Date();

                        // Exiting old zone
                        if (this.currentZone && this.zoneEntryTime) {
                            const duration = (now - this.zoneEntryTime) / 1000; // in seconds
                            this.zoneVisitLog.push({
                                zoneId: this.currentZone.id,
                                zoneName: this.currentZone.name,
                                enteredAt: this.zoneEntryTime.toISOString(),
                                exitedAt: now.toISOString(),
                                duration: duration.toFixed(2) + 's'
                            });
                            console.log(`🏁 Exited ${this.currentZone.name} after ${duration.toFixed(2)}s`);
                        }

                        // Entering new zone
                        if (newZone) {
                            console.log(`🚧 Entered ${newZone.name}`);
                            this.zoneEntryTime = now;
                        } else {
                            this.zoneEntryTime = null;
                        }

                        if (this.currentZone) this.currentZone.setHighlighted(false);
                        if (newZone) newZone.setHighlighted(true);

                        this.currentZone = newZone;
                    }

                }
            }

            animate(time = 0) {
                requestAnimationFrame(this.animate);

                if (!this.isPlayingBack) {
                    this.processFrame();
                    statusDisplay.textContent = `Status: Tracking - Zone: ${this.currentZone ? this.currentZone.name : 'Unknown'}`;
                    if (this.forkliftModel && this.forkliftPos) {
                        this.forkliftModel.position.copy(this.forkliftPos);
                    }

                } else {
                    this.playback(time);
                }

                this.zones.forEach(zone => {
                    if (zone.spriteLabel) {
                        zone.spriteLabel.quaternion.copy(this.camera.quaternion);
                    }
                });
                this.labelRenderer.render(this.scene, this.camera);

                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            captureItem() {
                const itemID = prompt('Enter Item ID:');
                if (!itemID) return alert('Item ID is required');

                const level = prompt('Enter level (floor, mid, top):', 'floor').toLowerCase();
                const levelIndex = this.levelHeights[level];

                if (levelIndex === undefined) {
                    alert('Invalid level. Please enter "floor", "mid", or "top".');
                    return;
                }

                const {
                    palletLength,
                    palletWidth,
                    palletHeight,
                    maxItemsPerRow,
                    levelHeights
                } = this;

                const forkliftPos = this.forkliftPos.clone();
                let itemPosition;

                if (level === 'floor') {
                    // Find overlapping floor items at forklift position
                    const overlappingItems = this.storedItems.filter(item =>
                        item.level === 'floor' &&
                        Math.abs(item.position.x - forkliftPos.x) < palletLength &&
                        Math.abs(item.position.z - forkliftPos.z) < palletWidth
                    );

                    if (overlappingItems.length >= 2) {
                        alert('Maximum pallet stack reached at this position.');
                        return;
                    }

                    const yOffset = overlappingItems.length * palletHeight;
                    itemPosition = new THREE.Vector3(forkliftPos.x, yOffset, forkliftPos.z);
                } else {
                    // MID or TOP rack levels
                    const rowSpacingX = palletLength + this.rackSlotGap;
                    const rowSpacingZ = palletWidth;
                    const yOffset = levelHeights[level] * (palletHeight + this.rackLevelGap);

                    const rowIndex = Math.round(forkliftPos.z / rowSpacingZ);
                    const slotIndex = Math.round(forkliftPos.x / rowSpacingX);

                    const itemsInRow = this.storedItems.filter(item =>
                        item.level === level &&
                        Math.round(item.position.z / rowSpacingZ) === rowIndex
                    );

                    if (itemsInRow.length >= maxItemsPerRow) {
                        alert(`Rack row ${rowIndex} at level ${level} is full.`);
                        return;
                    }

                    let finalSlotIndex = slotIndex;
                    const slotTaken = itemsInRow.some(item =>
                        Math.round(item.position.x / rowSpacingX) === slotIndex
                    );

                    if (slotTaken) {
                        for (let i = 0; i < maxItemsPerRow; i++) {
                            if (!itemsInRow.some(item => Math.round(item.position.x / rowSpacingX) === i)) {
                                finalSlotIndex = i;
                                break;
                            }
                        }
                    }

                    const finalX = finalSlotIndex * rowSpacingX;
                    const finalZ = rowIndex * rowSpacingZ;
                    itemPosition = new THREE.Vector3(finalX, yOffset, finalZ);

                    const collision = this.storedItems.some(item =>
                        item.level === level &&
                        item.position.equals(itemPosition)
                    );

                    if (collision) {
                        alert('An item already exists at this rack position.');
                        return;
                    }
                }

                this.storedItems.push({
                    id: itemID,
                    position: itemPosition.clone(),
                    level: level,
                    timestamp: new Date()
                });

/*                 const labelDiv = document.createElement('div');
                labelDiv.className = 'label';
                labelDiv.textContent = itemID;
                labelDiv.style.marginTop = '-1em';
                labelDiv.style.padding = '4px 8px';
                labelDiv.style.background = 'rgba(0, 0, 0, 0.7)';
                labelDiv.style.color = 'white';
                labelDiv.style.borderRadius = '4px';
                labelDiv.style.fontSize = '12px';

                const label = new CSS2DObject(labelDiv);
                label.position.set(0, 0.4, 0);

                const geometry = new THREE.BoxGeometry(palletLength, palletHeight, palletWidth);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
                const box = new THREE.Mesh(geometry, material);
                box.position.copy(itemPosition);
                box.name = `Item-${itemID}`;
                this.scene.add(box);
                box.add(label);
                this.itemMeshes.push(box); */


                if (!this.palletModel) {
    alert('Pallet model not loaded yet.');
    return;
}

const palletClone = this.palletModel.clone(true); // Deep clone with materials
palletClone.position.copy(itemPosition);
palletClone.name = `Item-${itemID}`;

// Optional: Adjust scale if needed
palletClone.scale.set(this.palletLength, this.palletHeight, this.palletWidth);

// Add label
const labelDiv = document.createElement('div');
labelDiv.className = 'label';
labelDiv.textContent = itemID;
labelDiv.style.marginTop = '-1em';
labelDiv.style.padding = '4px 8px';
labelDiv.style.background = 'rgba(0, 0, 0, 0.7)';
labelDiv.style.color = 'white';
labelDiv.style.borderRadius = '4px';
labelDiv.style.fontSize = '12px';

const label = new CSS2DObject(labelDiv);
label.position.set(0, 0.4, 0);
palletClone.add(label);

this.scene.add(palletClone);
this.itemMeshes.push(palletClone);

            }

            exportZoneVisitLog() {
                if (this.zoneVisitLog.length === 0) {
                    alert('No zone visit data to export.');
                    return;
                }

                const blob = new Blob([JSON.stringify(this.zoneVisitLog, null, 2)], {
                    type: 'application/json'
                });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `zone_visits_${new Date().toISOString()}.json`;
                a.click();

                URL.revokeObjectURL(url);
            }

            updateZoneLabels() {
                this.zones.forEach(zone => {
                    if (!zone.labelElement) return;

                    const center = zone.getCenter();
                    const pos = center.clone().project(this.camera);

                    const x = (pos.x * 0.5 + 0.5) * this.renderer.domElement.clientWidth;
                    const y = (-pos.y * 0.5 + 0.5) * this.renderer.domElement.clientHeight;

                    zone.labelElement.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                    zone.labelElement.style.display = (pos.z < 1 && pos.z > -1) ? 'block' : 'none';
                });
            }

            exportTrackedPath() {
                if (this.trackedPathPoints.length === 0) {
                    alert('No path data to export.');
                    return;
                }

                const exportData = this.trackedPathPoints.map(entry => ({
                    x: entry.position.x,
                    y: entry.position.y,
                    z: entry.position.z,
                    timestamp: entry.timestamp.toISOString()
                }));

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `forklift_path_${new Date().toISOString()}.json`;
                a.click();

                URL.revokeObjectURL(url);
            }

            saveToLocalStorage() {
                if (this.trackedPathPoints.length === 0) {
                    alert('No path data to save.');
                    return;
                }
                try {
                    const dataToSave = this.trackedPathPoints.map(entry => ({
                        x: entry.position.x,
                        y: entry.position.y,
                        z: entry.position.z,
                        timestamp: entry.timestamp.toISOString()
                    }));
                    localStorage.setItem('trackedPathData', JSON.stringify(dataToSave));
                    alert('Path data saved to LocalStorage.');
                } catch (e) {
                    alert('Error saving data: ' + e.message);
                }
            }

            loadFromLocalStorage() {
                try {
                    const dataString = localStorage.getItem('trackedPathData');
                    if (!dataString) {
                        alert('No saved path data found in LocalStorage.');
                        return;
                    }
                    const loadedData = JSON.parse(dataString);
                    if (!Array.isArray(loadedData)) throw new Error('Invalid data format.');

                    // Clear current path and load
                    this.trackedPathPoints = loadedData.map(entry => ({
                        position: new THREE.Vector3(entry.x, entry.y, entry.z),
                        timestamp: new Date(entry.timestamp)
                    }));

                    // Also load the last MAX_PATH_POINTS positions into the path line for rendering
                    this.points = new Array(MAX_PATH_POINTS).fill(null);
                    this.currentPointIndex = 0;
                    for (const entry of this.trackedPathPoints.slice(-MAX_PATH_POINTS)) {
                        this.updatePathLine(entry.position);
                    }
                    alert('Loaded path data from LocalStorage.');
                } catch (e) {
                    alert('Error loading data: ' + e.message);
                }
            }

            // Playback methods
            startPlayback() {
                if (this.trackedPathPoints.length === 0) {
                    alert('No path data to play back.');
                    return;
                }
                this.isPlayingBack = true;
                this.playbackIndex = 0;
                this.playbackLine.visible = true;
                this.playbackLastUpdateTime = 0;
                statusDisplay.textContent = 'Status: Playback started.';
            }

            stopPlayback() {
                this.isPlayingBack = false;
                this.playbackLine.visible = false;
                statusDisplay.textContent = 'Status: Playback stopped.';
            }

            playback(time) {
                if (!this.isPlayingBack) return;

                if (!this.playbackLastUpdateTime) {
                    this.playbackLastUpdateTime = time;
                    return;
                }

                // Advance playback index based on speed and elapsed time
                const elapsed = (time - this.playbackLastUpdateTime) * this.playbackSpeed;
                // Advance the index proportionally -  assume ~30 FPS so approx 33 ms per frame, we adapt:
                const pointsToAdvance = Math.floor(elapsed / 30);
                if (pointsToAdvance > 0) {
                    this.playbackIndex += pointsToAdvance;
                    this.playbackLastUpdateTime = time;
                }

                if (this.playbackIndex >= this.trackedPathPoints.length) {
                    this.stopPlayback();
                    return;
                }

                // Prepare playback path line geometry up to current playback index
                const len = Math.min(this.playbackIndex, MAX_PATH_POINTS);
                for (let i = 0; i < MAX_PATH_POINTS; i++) {
                    let pos;
                    if (i < len) {
                        const p = this.trackedPathPoints[this.playbackIndex - len + i];
                        pos = p ? p.position : new THREE.Vector3(0, 0, 0);
                    } else {
                        pos = new THREE.Vector3(0, 0, 0);
                    }
                    this.playbackLinePositions[i * 3] = pos.x;
                    this.playbackLinePositions[i * 3 + 1] = pos.y;
                    this.playbackLinePositions[i * 3 + 2] = pos.z;
                }
                this.playbackLineGeometry.attributes.position.needsUpdate = true;

                // Move the camera to follow playback point (optional)
                const currentPoint = this.trackedPathPoints[this.playbackIndex].position;
                this.camera.position.lerp(new THREE.Vector3(currentPoint.x, currentPoint.y + 5, currentPoint.z + 10), 0.1);
                this.camera.lookAt(currentPoint);
            }

            setPlaybackSpeed(speed) {
                this.playbackSpeed = speed;
            }

            setDefaultView(viewName) {
                switch (viewName) {
                    case 'top':
                        this.camera.position.set(0, 30, 0);
                        this.camera.up.set(0, 0, -1);
                        this.camera.lookAt(0, 0, 0);
                        break;

                    case 'front':
                        this.camera.position.set(0, 10, 30);
                        this.camera.up.set(0, 1, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;

                    case 'side':
                        this.camera.position.set(30, 10, 0);
                        this.camera.up.set(0, 1, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;

                    case 'isometric':
                        this.camera.position.set(20, 20, 20);
                        this.camera.up.set(0, 1, 0);
                        this.camera.lookAt(0, 0, 0);
                        break;

                    default:
                        console.warn('Unknown view:', viewName);
                }

                this.controls.update();
            }

            filterItemsByZone(zoneId) {
                return this.storedItems.filter(item => item.zoneId === zoneId);
            }

            filterItemsByLevel(level) {
                return this.storedItems.filter(item => item.level === level);
            }

            filterItemsByTime(startTime, endTime) {
                return this.storedItems.filter(item => {
                    const time = new Date(item.timestamp).getTime();
                    return time >= new Date(startTime).getTime() && time <= new Date(endTime).getTime();
                });
            }

            filterItemsByZoneAndLevel(zoneId, level) {
                return this.storedItems.filter(item => item.zoneId === zoneId && item.level === level);
            }

        }

        // ==== Setup & Initialization ====
        const tracker = new WarehouseTracker({
            palletLength: 1.2,
            palletWidth: 0.8,
            palletHeight: 1.44,
            maxItemsPerRow: 5,
            rackLevelGap: 2.5,
            levelHeights: { floor: 0, mid: 1, top: 2 }
        });

        // Webcam setup & start animation after video metadata ready
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    hiddenCanvas.width = video.videoWidth;
                    hiddenCanvas.height = video.videoHeight;
                    tracker.posit._width = hiddenCanvas.width; // update POSIT width
                    tracker.animate();
                    statusDisplay.textContent = 'Status: Video started, tracking...';
                };
            })
            .catch(err => {
                alert('Error accessing webcam: ' + err);
                statusDisplay.textContent = 'Status: Webcam access denied or error.';
            });

        // ==== UI Event Listeners ====
        captureButton.addEventListener('click', () => {
            tracker.captureItem();
        });

        exportButton.addEventListener('click', () => {
            tracker.exportTrackedPath();
        });

        startPlaybackBtn.addEventListener('click', () => {
            tracker.startPlayback();
            startPlaybackBtn.disabled = true;
            stopPlaybackBtn.disabled = false;
        });

        stopPlaybackBtn.addEventListener('click', () => {
            tracker.stopPlayback();
            startPlaybackBtn.disabled = false;
            stopPlaybackBtn.disabled = true;
        });

        saveDataBtn.addEventListener('click', () => {
            tracker.saveToLocalStorage();
        });

        loadDataBtn.addEventListener('click', () => {
            tracker.loadFromLocalStorage();
        });

        speedRange.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            tracker.setPlaybackSpeed(speed);
            speedDisplay.textContent = speed.toFixed(1) + 'x';
        });


        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, tracker.camera);

            const intersects = raycaster.intersectObjects(tracker.itemMeshes);
            if (intersects.length > 0) {
                const mesh = intersects[0].object;
                const itemId = mesh.name.replace('Item-', '');
                alert(`📦 Clicked Item ID: ${itemId}`);

                // Optional: highlight clicked item
                mesh.material.color.set(0xffff00); // highlight yellow

                // Optional: reset others
                tracker.itemMeshes.forEach(itemMesh => {
                    if (itemMesh !== mesh) {
                        itemMesh.material.color.set(0x00ffcc); // default color
                    }
                });
            }
        });

        document.getElementById('searchItemBtn').addEventListener('click', () => {
            const searchId = document.getElementById('searchItemInput').value.trim();
            if (!searchId) return alert('Please enter an Item ID.');

            const match = tracker.itemMeshes.find(mesh => mesh.name === `Item-${searchId}`);
            if (match) {
                match.material.color.set(0x00ff00); // green highlight
                tracker.camera.position.set(match.position.x, match.position.y + 5, match.position.z + 5);
                tracker.camera.lookAt(match.position);

                // Reset others
                tracker.itemMeshes.forEach(mesh => {
                    if (mesh !== match) mesh.material.color.set(0x00ffcc);
                });
            } else {
                alert(`Item ID ${searchId} not found.`);
            }
        });
        document.getElementById('btnTopView').onclick = () => tracker.setDefaultView('top');
        document.getElementById('btnFrontView').onclick = () => tracker.setDefaultView('front');
        document.getElementById('btnSideView').onclick = () => tracker.setDefaultView('side');
        document.getElementById('btnIsoView').onclick = () => tracker.setDefaultView('isometric');
        document.getElementById('filterItemsBtn').addEventListener('click', () => {
            const zoneValue = document.getElementById('zoneFilter').value;
            const levelValue = document.getElementById('levelFilter').value;

            let filteredItems = tracker.storedItems;

            if (zoneValue) {
                filteredItems = filteredItems.filter(item => item.zoneId === parseInt(zoneValue));
            }

            if (levelValue) {
                filteredItems = filteredItems.filter(item => item.level === levelValue);
            }

            console.log('Filtered Items:', filteredItems);

            // Optional: Highlight filtered items in the scene
            tracker.scene.children.forEach(obj => {
                if (obj.isMesh && obj.name.startsWith('Item-')) {
                    const match = filteredItems.find(item => obj.name === `Item-${item.id}`);
                    obj.material.color.set(match ? 0xffff00 : 0x00ffcc); // yellow highlight if matched
                }
            });
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            tracker.camera.aspect = window.innerWidth / window.innerHeight;
            tracker.camera.updateProjectionMatrix();
            tracker.renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>
