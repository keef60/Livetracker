<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ArUco Tracker with Spaghetti Chart & Zones</title>
  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    canvas { display: block; }
    #video { position: absolute; top: 0; left: 0; z-index: -1; }
    #captureButton { position: absolute; top: 10px; left: 10px; z-index: 10; padding: 8px 12px; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "./three.js-dev/build/three.module.js",
      "three/addons/": "./three.js-dev/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <button id="captureButton">Capture Item Location</button>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas" width="640" height="480" style="display:none;"></canvas>
  <canvas id="spaghettiChartCanvas"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import AR from './js-aruco2-master/src/aruco.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import POS from './js-aruco2-master/src/posit1.js';

    // ==== Constants & Config ====
    const MARKER_SIZE = 0.04;           // Marker size in meters
    const SMOOTHING_ALPHA = 0.2;        // EMA smoothing factor
    const MAX_DISTANCE_JUMP = 1.5;      // Max allowed jump to filter outliers
    const MAX_PATH_POINTS = 500;        // Max points in the path line

    // ==== Elements & Contexts ====
    const video = document.getElementById('video');
    const hiddenCanvas = document.getElementById('canvas');
    const hiddenCtx = hiddenCanvas.getContext('2d');
    const spaghettiCanvas = document.getElementById('spaghettiChartCanvas');

    // ==== Tracker Class ====
    class WarehouseTracker {
      constructor() {
        // POSIT setup for pose estimation
        this.posit = new POS.Posit(MARKER_SIZE, hiddenCanvas.width);

        // ArUco marker detector
        this.detector = new AR.Detector({ dictionaryName: 'ARUCO' });

        // Three.js scene setup
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ canvas: spaghettiCanvas });
        this.renderer.setSize(window.innerWidth, window.innerHeight);

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableZoom = true;
        this.controls.minDistance = 2;
        this.controls.maxDistance = 50;

        this.camera.position.set(0, 10, 20);
        this.camera.up.set(0, 0, -1);
        this.camera.lookAt(0, 0, 0);
        this.controls.update();

        this.scene.add(new THREE.GridHelper(10, 10));

        // Forklift path tracking setup
        this.points = new Array(MAX_PATH_POINTS).fill(null);
        this.currentPointIndex = 0;

        // Create a fixed-size BufferGeometry for performance
        const positions = new Float32Array(MAX_PATH_POINTS * 3); // x,y,z for each point
        this.lineGeometry = new THREE.BufferGeometry();
        this.lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        this.line = new THREE.Line(this.lineGeometry, this.lineMaterial);
        this.scene.add(this.line);

        this.smoothedPos = null;
        this.forkliftPos = new THREE.Vector3();
        this.currentZoneId = null;
        this.storedItems = [];

        this.animate = this.animate.bind(this);
      }

      estimatePose(marker) {
        const corners = marker.corners.map(c => ({ x: c.x, y: c.y }));
        const pose = this.posit.pose(corners);
        if (!pose || !pose.bestRotation || !pose.bestTranslation) return null;
        return {
          translation: pose.bestTranslation,
          rotation: pose.bestRotation
        };
      }

      updatePathLine(newPos) {
        // Add new point to the circular buffer
        this.points[this.currentPointIndex] = newPos.clone();
        this.currentPointIndex = (this.currentPointIndex + 1) % MAX_PATH_POINTS;

        // Update BufferGeometry positions attribute
        const positions = this.lineGeometry.attributes.position.array;
        let idx = 0;

        // Write points starting from currentPointIndex to the end, then beginning to currentPointIndex
        for (let i = 0; i < MAX_PATH_POINTS; i++) {
          const point = this.points[(this.currentPointIndex + i) % MAX_PATH_POINTS];
          if (point) {
            positions[idx++] = point.x;
            positions[idx++] = point.y;
            positions[idx++] = point.z;
          } else {
            // Fill empty space with last valid point or zeros
            if (idx >= 3) {
              positions[idx] = positions[idx - 3];
              positions[idx+1] = positions[idx - 2];
              positions[idx+2] = positions[idx - 1];
            } else {
              positions[idx++] = 0;
              positions[idx++] = 0;
              positions[idx++] = 0;
            }
            idx += 3;
          }
        }
        this.lineGeometry.attributes.position.needsUpdate = true;
      }

      processFrame() {
        if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

        // Draw video frame to hidden canvas for processing
        hiddenCtx.drawImage(video, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
        const imageData = hiddenCtx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);

        // Detect markers
        const markers = this.detector.detect(imageData);

        let sumPos = new THREE.Vector3();
        let validMarkersCount = 0;
        let closestMarker = null;
        let closestZ = Infinity;

        markers.forEach(marker => {
          const pose = this.estimatePose(marker);
          if (!pose) return;

          const t = pose.translation;
          if ([t[0], t[1], t[2]].some(v => !isFinite(v) || isNaN(v))) return;

          const pos = new THREE.Vector3(t[0], -t[1], -t[2]);
          if (!isFinite(pos.z) || isNaN(pos.z)) return;

          sumPos.add(pos);
          validMarkersCount++;

          if (pos.z < closestZ) {
            closestZ = pos.z;
            closestMarker = marker;
          }
        });

        this.currentZoneId = closestMarker ? closestMarker.id : null;

        if (validMarkersCount > 0) {
          const avgPos = sumPos.divideScalar(validMarkersCount);

          if (!this.smoothedPos) {
            this.smoothedPos = avgPos.clone();
          } else {
            // Ignore large jumps
            if (this.smoothedPos.distanceTo(avgPos) <= MAX_DISTANCE_JUMP) {
              this.smoothedPos.lerp(avgPos, SMOOTHING_ALPHA);
            } else {
              console.warn('Outlier detected, skipping frame');
            }
          }

          this.forkliftPos.copy(this.smoothedPos);
          this.updatePathLine(this.forkliftPos);
        }

        this.controls.update();
        this.renderer.render(this.scene, this.camera);
      }

      animate() {
        requestAnimationFrame(this.animate);
        this.processFrame();
      }

      captureItem(itemID) {
        if (!itemID) return alert('Item ID is required');

        this.storedItems.push({
          id: itemID,
          position: this.forkliftPos.clone(),
          zoneMarkerId: this.currentZoneId || 'Unknown',
          timestamp: new Date()
        });

        alert(`Captured ${itemID} at position (${this.forkliftPos.x.toFixed(2)}, ${this.forkliftPos.y.toFixed(2)}, ${this.forkliftPos.z.toFixed(2)}) in zone (marker ID): ${this.currentZoneId || 'Unknown'}`);
        console.log('Stored item', itemID, 'at position', this.forkliftPos, 'in zone marker ID', this.currentZoneId);
      }
    }

    // ==== Initialization ====
    const tracker = new WarehouseTracker();

    // Setup webcam feed and start animation
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => {
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          hiddenCanvas.width = video.videoWidth;
          hiddenCanvas.height = video.videoHeight;
          tracker.posit._width = hiddenCanvas.width; // update POSIT width
          tracker.animate();
        };
      })
      .catch(err => {
        alert('Error accessing webcam: ' + err);
      });

    // Capture button event
    document.getElementById('captureButton').addEventListener('click', () => {
      const itemID = prompt('Enter Item ID:');
      tracker.captureItem(itemID);
    });

    // Handle window resizing
    window.addEventListener('resize', () => {
      tracker.camera.aspect = window.innerWidth / window.innerHeight;
      tracker.camera.updateProjectionMatrix();
      tracker.renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
