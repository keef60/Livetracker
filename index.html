<!DOCTYPE html>
<html>

<head>
  <title>Camera Position via Trilateration</title>
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      user-select: none;
    }

    #canvas-container {
      text-align: center;
    }
  </style>

  <!-- ArUco + math libraries -->
  <script src="js/cv.js"></script>
  <script src="js/aruco.js"></script>
  <script src="./js/mathjs.js"></script>

</head>

<body>
  <video id="video" autoplay playsinline style="display:none;"></video>
  <canvas id="canvas" width="640" height="480"></canvas>
  <div id="threeContainer" style="margin-left: 20px;"></div>
  <div id="infoPanel"
    style="position:absolute; top:10px; left:10px; background:#fff; padding:10px; font-family:monospace; font-size:14px; border:1px solid #ccc;">
    <b>Detected Tags:</b><br>
    <div id="tagInfo"></div>
    <br>
    <b>Camera Position (m):</b>
    <div id="camInfo"></div>
    <hr>
    <b>Scanned Items:</b>
    <div id="scannedList"></div>
  </div>

  <!-- Three.js + App Logic -->
  <script type="module">
    import * as THREE from './js/three.js';

    let video, canvas, context, imageData, detector;

    const knownTags3D = {
      1: { x: 0, y: 0, z: 9 },
      2: { x: 13, y: 0, z: 9 },
      3: { x: 13, y: 14, z: 9 },
      4: { x: 0, y: 14, z: 9 },
      5: { x: 6.5, y: 7, z: 9 }
    };

    const itemScanCounts = {};
    const labelSprites = [];
    let scanBuffer = "";
    let lastScanTime = 0;
    const barcodeScanDelay = 1000;

    let lastCameraPos = { x: 20, y: 12, z: 20 };
    const smoothingFactor = 0.009;
    const tagSpheres = [];

    function onLoad() {
      video = document.getElementById("video");
      canvas = document.getElementById("canvas");
      context = canvas.getContext("2d");

      navigator.mediaDevices
        .getUserMedia({ video: true })
        .then(stream => video.srcObject = stream)
        .catch(err => console.error(err));

      detector = new AR.Detector();
      init3DScene();
      requestAnimationFrame(tick);
    }

    window.addEventListener('keydown', (e) => {
      const now = Date.now();

      if (now - lastScanTime > barcodeScanDelay) scanBuffer = "";
      lastScanTime = now;

      if (e.key === 'Enter') {
        handleBarcodeScan(scanBuffer.trim());
        scanBuffer = "";
      } else {
        scanBuffer += e.key;
      }
    });

    function handleBarcodeScan(code) {
      if (!itemScanCounts[code]) {
        itemScanCounts[code] = 1;
        console.log(`Scanned "${code}" once.`);
      } else {
        itemScanCounts[code]++;
        if (itemScanCounts[code] === 2) {
          console.log(`Second scan for "${code}". Placing object.`);
          if (lastCameraPos) {
            const box = new THREE.Mesh(
              new THREE.BoxGeometry(0.8, 0.8, 0.8),
              new THREE.MeshStandardMaterial({ color: 0x0000ff })
            );
            box.position.set(lastCameraPos.x, lastCameraPos.z, lastCameraPos.y);
            scene.add(box);

            const label = createTextLabel(code);
            label.position.set(lastCameraPos.x, lastCameraPos.z + 1.0, lastCameraPos.y);
            scene.add(label);
            labelSprites.push(label);
          }
        }
      }
      updateScannedItemsDisplay();
    }

    function updateScannedItemsDisplay() {
      const scannedListHTML = Object.keys(itemScanCounts)
        .map(code => `<li>${code}: ${itemScanCounts[code]} scan(s)</li>`)
        .join('');
      document.getElementById("scannedList").innerHTML = `<ul>${scannedListHTML}</ul>`;
    }

    function createTextLabel(text) {
  const dpi = window.devicePixelRatio || 1;

  const width = 512;
  const height = 128;

  const canvas = document.createElement('canvas');
  canvas.width = width * dpi;
  canvas.height = height * dpi;
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;

  const ctx = canvas.getContext('2d');
  ctx.scale(dpi, dpi); // For high DPI screens

  // Optional: Draw semi-transparent background box
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(0, 0, width, height);

  // Optional: White border around the background
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 2;
  ctx.strokeRect(0, 0, width, height);

  // Text styling
  ctx.fillStyle = 'white';
  ctx.font = 'bold 48px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, width / 2, height / 2);

  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  texture.needsUpdate = true;

  const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(material);
  sprite.scale.set(5, 1.5, 1); // Bigger label in scene

  return sprite;
}


    function smoothCameraPosition(newPos) {
      return {
        x: lastCameraPos.x + smoothingFactor * (newPos.x - lastCameraPos.x),
        y: lastCameraPos.y + smoothingFactor * (newPos.y - lastCameraPos.y),
        z: lastCameraPos.z + smoothingFactor * (newPos.z - lastCameraPos.z)
      };
    }

    function tick() {
      requestAnimationFrame(tick);
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        const markers = detector.detect(imageData);
        drawCorners(markers);
        drawIds(markers);

        if (markers.length >= 4) {
          const tagData = markers
            .filter(marker => knownTags3D.hasOwnProperty(marker.id))
            .slice(0, 4)
            .map(marker => ({
              id: marker.id,
              pos: knownTags3D[marker.id],
              distance: calculateDistanceFromCamera(marker)
            }));

          if (tagData.length >= 4) {
            const cameraPos = trilaterate3D(tagData);
            if (cameraPos) {
              const smoothedCameraPos = smoothCameraPosition(cameraPos);
              update3DMarkers(tagData, smoothedCameraPos);
              lastCameraPos = smoothedCameraPos;
            }
          }
        }
      }
    }

    function drawCorners(markers) {
      context.lineWidth = 3;
      context.strokeStyle = "red";
      markers.forEach(marker => {
        context.beginPath();
        for (let j = 0; j < marker.corners.length; j++) {
          const c1 = marker.corners[j];
          const c2 = marker.corners[(j + 1) % marker.corners.length];
          context.moveTo(c1.x, c1.y);
          context.lineTo(c2.x, c2.y);
        }
        context.stroke();
      });
    }

    function drawIds(markers) {
      context.fillStyle = "blue";
      context.font = "20px monospace";
      markers.forEach(marker => {
        const x = Math.min(...marker.corners.map(c => c.x));
        const y = Math.min(...marker.corners.map(c => c.y));
        context.fillText(marker.id, x, y);
        if (marker.id === 5) {
          context.fillStyle = "green";
          context.fillText("Center", x + 10, y + 10);
        }
      });
    }

    function calculateDistanceFromCamera(marker) {
      const REAL_MARKER_SIZE = 1.5; // cm
      const FOCAL_LENGTH = 1300;    // px
      const dx = marker.corners[0].x - marker.corners[1].x;
      const dy = marker.corners[0].y - marker.corners[1].y;
      const pixelSize = Math.sqrt(dx * dx + dy * dy);
      const distanceCm = (FOCAL_LENGTH * REAL_MARKER_SIZE) / pixelSize;
      return distanceCm * 0.393701; // inches
    }

    function trilaterate3D(tags) {
      if (tags.length < 4) return null;
      const A = [], b = [];
      for (let i = 1; i < tags.length; i++) {
        const P1 = tags[0].pos;
        const Pi = tags[i].pos;
        const r1 = tags[0].distance;
        const ri = tags[i].distance;
        A.push([2 * (Pi.x - P1.x), 2 * (Pi.y - P1.y), 2 * (Pi.z - P1.z)]);
        b.push(
          r1 * r1 - ri * ri
          - P1.x * P1.x + Pi.x * Pi.x
          - P1.y * P1.y + Pi.y * Pi.y
          - P1.z * P1.z + Pi.z * Pi.z
        );
      }
      const AT = math.transpose(A);
      const ATA = math.multiply(AT, A);
      const ATb = math.multiply(AT, b);
      const pos = math.lusolve(ATA, ATb);
      return { x: pos[0][0], y: pos[1][0], z: pos[2][0] };
    }

    let scene, camera3D, renderer, cameraMarker;

    function init3DScene() {
      scene = new THREE.Scene();
      const axesHelper = new THREE.AxesHelper(3);
      axesHelper.position.set(6.5, 0, 7);
      scene.add(axesHelper);

      camera3D = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 100);
      camera3D.position.set(12, 12, 20);
      camera3D.lookAt(6.5, 4.5, 7);

      renderer = new THREE.WebGLRenderer();
      renderer.setSize(800, 600);
      document.getElementById("threeContainer").appendChild(renderer.domElement);

      const boxGeometry = new THREE.BoxGeometry(13, 9, 14);
      const boxEdges = new THREE.EdgesGeometry(boxGeometry);
      const boxMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa });
      const boxWireframe = new THREE.LineSegments(boxEdges, boxMaterial);
      boxWireframe.position.set(13 / 2, 9 / 2, 14 / 2);
      scene.add(boxWireframe);

      const gridHelper = new THREE.GridHelper(20, 20);
      gridHelper.position.set(6.5, 0, 7);
      scene.add(gridHelper);

      const light = new THREE.PointLight(0xffffff, 1, 100);
      light.position.set(13, 9, 14);
      scene.add(light);

      const ambient = new THREE.AmbientLight(0xffffff, 0.95);
      scene.add(ambient);

      const camGeometry = new THREE.SphereGeometry(1, 16, 16);
      const camMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      cameraMarker = new THREE.Mesh(camGeometry, camMaterial);
      scene.add(cameraMarker);

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      labelSprites.forEach(sprite => {
        sprite.lookAt(camera3D.position);
      });
      renderer.render(scene, camera3D);
    }

    function update3DMarkers(tagData, cameraPos) {
      tagSpheres.forEach(s => scene.remove(s));
      tagSpheres.length = 0;

      tagData.forEach(tag => {
        const sphere = new THREE.Mesh(
          new THREE.SphereGeometry(1, 12, 12),
          new THREE.MeshStandardMaterial({ color: 0x00ff00 })
        );
        sphere.position.set(tag.pos.x, tag.pos.z, tag.pos.y);
        scene.add(sphere);
        tagSpheres.push(sphere);
      });

      if (cameraPos) {
        cameraMarker.position.set(cameraPos.x, cameraPos.z, cameraPos.y);
        document.getElementById("camInfo").innerHTML = `X: ${cameraPos.x.toFixed(2)}<br>Y: ${cameraPos.y.toFixed(2)}<br>Z: ${cameraPos.z.toFixed(2)}`;
      }

      const info = tagData.map(tag =>
        `Tag ${tag.id}: (${tag.pos.x}, ${tag.pos.y}, ${tag.pos.z}) — Dist: ${tag.distance.toFixed(2)}in`
      ).join("<br>");
      document.getElementById("tagInfo").innerHTML = info;
    }

    window.onload = onLoad;
  </script>
</body>

</html>